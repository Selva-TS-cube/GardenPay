var f = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var u = (r, t, e) => (f(r, t, "read from private field"), e ? e.call(r) : t.get(r)), h = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, l = (r, t, e, s) => (f(r, t, "write to private field"), s ? s.call(r, e) : t.set(r, e), e);
const d = (r) => new Promise((t) => setTimeout(t, r));
class x {
  /**
   * @param {number} maxRetries - The maximum number of retries, if less < 0 then it is set to 0
   * @param {number} delay - The delay between retries
   */
  constructor(t, e) {
    this.maxRetries = Math.max(t, 0), this.delay = e;
  }
  /**
   * Retries a function until it succeeds or the max number of retries is reached
   *
   * @param {() => Promise<T>} fn - The function to retry
   * @return {Promise<T>} a Promise that resolves to the result of the function
   */
  async retry(t) {
    let e = 0, s;
    for (; e < this.maxRetries + 1; )
      try {
        return await t();
      } catch (n) {
        e++, s = n, await d(this.delay * e);
      }
    throw s;
  }
}
const p = (r) => {
  try {
    return JSON.parse(r);
  } catch {
    return r;
  }
};
class k {
  static async _postWithFallback(t, e) {
    let s = "";
    for (const n of t)
      try {
        const a = await fetch(n, {
          method: "POST",
          ...e
        });
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback logic.
   *
   * @param {string[]} input - array of URLs to send the POST request to
   * @param {RequestInit} [init] - optional request initialization options
   * @return {Promise<T>} a Promise that resolves to the parsed response data
   */
  static async postWithFallback(t, e) {
    return await w(e).retry(
      () => this._postWithFallback(t, e)
    );
  }
  static async _getWithFallback(t, e) {
    let s = "";
    for (const n of t)
      try {
        const a = await fetch(n, e);
        if (a.status >= 500) {
          s = await (a.text() || a.json());
          continue;
        }
        return await this.parse(a);
      } catch (a) {
        s = g(a);
        continue;
      }
    throw new Error(s || "All APIs failed");
  }
  /**
   * Asynchronously sends a POST request to multiple URLs with fallback mechanism.
   *
   * @param {string[]} input - An array of URLs to retrieve data from.
   * @param {RequestInit} [init] - Optional request options.
   * @return {Promise<T>} A promise that resolves to the retrieved data.
   */
  static async getWithFallback(t, e) {
    return await w(e).retry(
      () => this._getWithFallback(t, e)
    );
  }
  static async _get(t, e) {
    return await this.parse(await fetch(t, e));
  }
  /**
   * Asynchronously retrieves data of type T from the specified URL or RequestInfo, with optional initialization options.
   *
   * @param {RequestInfo | URL} input - The URL or RequestInfo to fetch data from
   * @param {RequestInit} init - Optional initialization options for the fetch request
   * @return {Promise<T>} The retrieved data of type T
   */
  static async get(t, e) {
    return await w(e).retry(() => this._get(t, e));
  }
  static async _post(t, e) {
    return await this.parse(
      await fetch(t, {
        method: "POST",
        ...e
      })
    );
  }
  /**
   * Asynchronously sends a POST request to the specified URL or RequestInfo, with optional initialization options.
   */
  static async post(t, e) {
    return await w(e).retry(() => this._post(t, e));
  }
  /**
   * Parses the response and returns the result as the specified type.
   *
   * @param {Response} res - the response object to be parsed
   * @return {Promise<T>} the parsed result of type T
   */
  static async parse(t) {
    const e = await t.text();
    if (t.status >= 200 && t.status < 300)
      return p(e);
    throw new Error(e);
  }
}
function g(r) {
  return (r == null ? void 0 : r.message) || (r == null ? void 0 : r.toString()) || "unknown error";
}
const w = (r) => new x((r == null ? void 0 : r.retryCount) ?? 2, (r == null ? void 0 : r.retryDelay) ?? 1e3);
class v {
  constructor(t) {
    this.url = t;
  }
  /**
   * Sends a request and returns a response.
   *
   * @param {RpcRequest} request - The request to send.
   * @return {Promise<RpcResponse<T>>} - A promise that resolves to the response.
   */
  async sendRequest(t) {
    try {
      return await k.post(this.url, {
        body: JSON.stringify(t)
      });
    } catch (e) {
      return p(e.message);
    }
  }
}
const E = (r, t) => {
  if (!r)
    throw new Error(t);
  return r;
}, F = (r) => r.startsWith("0x") ? r : `0x${r}`, P = (r) => r.startsWith("0x") ? r.slice(2) : r;
var c, i, o;
class y {
  constructor(t, e, s = void 0) {
    h(this, c, void 0);
    h(this, i, void 0);
    h(this, o, void 0);
    l(this, c, t), l(this, o, s), l(this, i, e);
  }
  get ok() {
    return u(this, c);
  }
  get error() {
    return u(this, o);
  }
  get val() {
    return u(this, i);
  }
}
c = new WeakMap(), i = new WeakMap(), o = new WeakMap();
const W = (r) => new y(!0, r), R = void 0, _ = (r, ...t) => {
  if (typeof r == "string" && t && t.length > 0) {
    let e = [r, ...t].map((s) => {
      if (s) {
        if (s instanceof Error)
          return s.message;
        if (typeof s == "string")
          return s;
        if (s != null && s.toString)
          return s.toString();
      }
    });
    return new y(
      !1,
      null,
      e.filter((s) => s !== void 0).join(" ")
    );
  }
  return new y(!1, null, r);
};
async function S(r) {
  try {
    const t = await r();
    return t.ok || t.error || t.val ? Promise.resolve(t) : W(t);
  } catch (t) {
    return _(t);
  }
}
export {
  _ as Err,
  k as Fetcher,
  v as JsonRpc,
  W as Ok,
  y as Result,
  x as Retry,
  R as Void,
  E as ensureVal,
  S as executeWithTryCatch,
  p as safeParseJson,
  d as sleep,
  P as trim0x,
  F as with0x
};
